import argparse
import numpy as np
import pickle
import sys

def flattenize(data, feature):
    x = []
    y = []
    for genre in data:
        for file_path in data[genre]:
            feature_data = data[genre][file_path][feature]
            x.append(feature_data)
            y.append(genre)
    return x, y


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--feature",
                        help="The feature to use",
                        required=False)
    parser.add_argument("-l", "--list-features", action="store_true",
                        help="List the available features",
                        required=False)
    parser.add_argument("-i", "--input",
                        type=argparse.FileType('rb'),
                        help="Path to pickle generated by musicc-datagen.",
                        required=True)
    parser.add_argument("-o", "--output",
                        type=argparse.FileType('wb'),
                        help="Path to output pickle containing x (features) "
                        "and y (labels)",
                        required=False)
    parser.add_argument("-v", "--value-fill",
                        help="Outputs all the matrixes with the same shape "
                        "filling with the given value",
                        required=False)

    args = parser.parse_args()
    data = pickle.load(args.input)

    if args.list_features:
        for key in data.keys():
            print(key)
        sys.exit(0)

    if args.feature is not None:
        output_data = flattenize(data, args.feature)
        if args.value_fill:
            x, y = output_data
            shape_x = max(set([m.shape[0] for m in x]))
            shape_y = max(set([m.shape[1] for m in x]))
            shape = shape_x, shape_y
            new_x = []
            for matrix in x:
                value = int(args.value_fill)
                for axis in (0, 1):
                    idx = tuple(range(matrix.shape[axis], shape[axis]))
                    if matrix.shape[axis] < shape[axis]:
                        if axis == 1:
                            chunk = np.full((matrix.shape[0], shape[axis] - matrix.shape[axis]), value)
                        else:
                            chunk = np.full((shape[axis] - matrix.shape[axis], matrix.shape[1]), value)
                        matrix = np.append(matrix, chunk, axis=axis)
                new_x.append(matrix)
            output_data = new_x, y
        if args.output is not None:
            pickle.dump(output_data, args.output, protocol=pickle.HIGHEST_PROTOCOL)
            args.output.close()
        else:
            print(output_data)
