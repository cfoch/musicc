import argparse
import librosa
import librosa.display
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import os
import pickle
import sys


class PlotWrapper:
    @classmethod
    def melspectrogram(cls, x):
        return librosa.power_to_db(x, ref=np.max)


def write_spectogram(feature_data, spectogram_path, args):
    fig = plt.figure(figsize=(args.image_size, args.image_size))
    if args.prespectrogram_wrapper and hasattr(PlotWrapper, args.feature):
        wrapper_func = getattr(PlotWrapper, args.feature)
        feature_data = wrapper_func(feature_data)
    librosa.display.specshow(feature_data)
    plt.subplots_adjust(left=0, right=1, top=1, bottom=0)
    with open(spectogram_path, 'wb') as outfile:
        fig.canvas.print_png(outfile)
    plt.close()

def flattenize(data, args):
    x = []
    y = []
    for genre in data:
        for file_path in data[genre]:
            for i, entry in enumerate(data[genre][file_path]):
                feature_data = entry["features"][args.feature]

                if args.spectogram_path is not None:
                    spectogram_filename = "%s_%d.png" %\
                        (os.path.basename(file_path), i)
                    spectogram_path = os.path.join(args.spectogram_path, genre,
                                                   args.feature,
                                                   spectogram_filename)
                    spectogram_dir = os.path.dirname(spectogram_path)
                    print(spectogram_path)
                    if not os.path.isdir(spectogram_dir):
                        os.makedirs(spectogram_dir)
                    write_spectogram(feature_data, spectogram_path, args)
                    x.append(spectogram_path)
                else:
                    x.append(feature_data)
                y.append(genre)
    return x, y


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--feature",
                        help="The feature to use",
                        required=False)
    parser.add_argument("-l", "--list-features", action="store_true",
                        help="List the available features",
                        required=False)
    parser.add_argument("-i", "--input",
                        type=argparse.FileType('rb'),
                        help="Path to pickle generated by musicc-datagen.",
                        required=True)
    parser.add_argument("-o", "--output",
                        type=argparse.FileType('wb'),
                        help="Path to output pickle containing x (features) "
                        "and y (labels)",
                        required=False)
    parser.add_argument("-w", "--prespectrogram-wrapper", action="store_true",
                        help="Apply a function to the data before creating the "
                        "spectrogram",
                        default=False,
                        required=False)
    parser.add_argument("-s", "--spectogram-path",
                        help="Path to the parent directory containing "
                        "spectogram image files.",
                        required=False)
    parser.add_argument("-S", "--image-size",
                        type=int,
                        help="Image size. Size will be S x S.",
                        default=5,
                        required=False)
    parser.add_argument("-v", "--value-fill",
                        help="Outputs all the matrixes with the same shape "
                        "filling with the given value",
                        required=False)

    args = parser.parse_args()
    data = pickle.load(args.input)

    if args.list_features:
        for key in data.keys():
            print(key)
        sys.exit(0)

    if args.feature is not None:
        output_data = flattenize(data, args)
        if not args.spectogram_path and args.value_fill:
            x, y = output_data
            shape_x = max(set([m.shape[0] for m in x]))
            shape_y = max(set([m.shape[1] for m in x]))
            shape = shape_x, shape_y
            new_x = []
            for matrix in x:
                value = int(args.value_fill)
                for axis in (0, 1):
                    idx = tuple(range(matrix.shape[axis], shape[axis]))
                    if matrix.shape[axis] < shape[axis]:
                        if axis == 1:
                            chunk = np.full((matrix.shape[0], shape[axis] - matrix.shape[axis]), value)
                        else:
                            chunk = np.full((shape[axis] - matrix.shape[axis], matrix.shape[1]), value)
                        matrix = np.append(matrix, chunk, axis=axis)
                new_x.append(matrix)
            output_data = np.array(new_x), y
        if args.output is not None:
            pickle.dump(output_data, args.output, protocol=pickle.HIGHEST_PROTOCOL)
            args.output.close()
        else:
            print(output_data)
